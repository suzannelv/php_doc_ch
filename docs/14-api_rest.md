---
sidebar_position: 14
slug: api_rest
---

# API REST

REST 代表**RE**presentational **S**tate **T**ransfer，這是在開發 API 時可用的架構風格。 它由[Roy Fielding](https://en.wikipedia.org/wiki/Roy_Fielding)於 2000 年設計。

## 資源

REST API 將公開關於**資源**的**操作**。 每個操作都代表了更改應用程式內資源狀態的可能性。

通常，我們會為資源使用**名稱**。 儘管這可能會有所變化，透過 API 公開的資源, 我們將首先定義名稱，以表示我們資料庫中的表。

因此，我們可以找到像 `users`、`products`、`emails` 等資源...

:::info 名稱和動詞
有時，當我們定義資源時，我們當然可以使用動詞。 這些資源並不總是代表資料庫中的表。

例如，如果我實現了一個搜尋引擎，並希望透過我的應用程式介面提供該搜尋引擎，那麼在我的應用程式介面中就需要一個 `/search` **端點**。
:::

## 操作

對於資料庫表來說，最常見的操作通常可以簡化為 CRUD（Create/Read/Update/Delete），用於管理該表的記錄的生命週期。

### HTTP 動詞

實際上，HTTP 協定的實現方式已經允許我們表示對資源執行操作。

因此，更容易定義一個**資源的端點**，然後根據需要使用不同的**HTTP 方法**。

讓我們來看看不同的 HTTP 方法以及在呼叫 REST API 時它們的含義：

> 假設我們的範例資源是一個名為 `emails` 的資源，具有端點 `/emails`。

| 操作                  | 描述                                                                     | 範例                               |
| --------------------- | ------------------------------------------------------------------------ | ---------------------------------- |
| `GET /emails`         | 獲取所有電子郵件                                                         | `GET /emails`                      |
| `GET /emails/{id}`    | 檢索 id 位於 URL 中的電子郵件                                            | `GET /emails/4`                    |
| `POST /emails`        | 根據請求正文中提供的資料建立新電子郵件                                   | `POST /emails { "test@test.com"}`  |
| `PUT /emails/{id}`    | 將現有電子郵件替換為請求正文中指定的新數據，或建立電子郵件（如果不存在） | `PUT /emails/6 { "bob@test.com"} ` |
| `PATCH /emails/{id}`  | 使用請求正文中指定的資料部分更新現有電子郵件                             | `PATCH /emails/6 {"bob@test.com"}` |
| `DELETE /emails/{id}` | 從資料庫中刪除一封電子郵件                                               | `DELETE /emails/6`                 |

### 自定義操作

如前面所述，終端點並不總是具有明確的名稱。

在這種情況下，雖然最初我們可能不希望描述我們要執行的操作（例如，`/deleteEmail`、`/addEmail` 等），但向 API 客戶端提供特定功能可能會很有用。

例如，**線上商店**中的 `/search` 端點與 `POST` 方法相結合，可用於根據多種條件搜尋產品（在多個表之間進行多重連接）：

```json
POST /search { name: "My product", category: "Electronics", colors: ["red", "green", "blue"] }
```

如果 API 找到了產品，就會傳回一個產品清單。

但是，我們也可以想像，在我們的電子郵件 API 中，我們想按值搜尋一個產品。 `/emails` 可以接受一個 `GET` 參數作為過濾器。

這並不是真正的搜索，它涉及到資料庫中的多個表，而是對資源的過濾。

> 記住，使用 GET 方法呼叫 `/emails` 基本上等同於請求所有電子郵件

這樣，我們的查詢就變成了 ：

```json
GET /emails?value=bob@test.com
```

通常，我們會向客戶端發送 `JSON` 格式的回應。

然後，根據回應的性質，也會套用適當的 **HTTP 回應(響應)代碼**。

例如：

| 情境                                                   | 結果                                 | 回應代碼                                 |
| ------------------------------------------------------ | ------------------------------------ | ---------------------------------------- |
| 我想使用 POST 方法建立一個資源                         | 資源已建立成功                       | 代碼 201 已創建                          |
| 我想用 POST 方法建立資源                               | 傳輸的資料不正確                     | 代碼 4​​00 錯誤請求或 422 無法處理的內容 |
| 我想使用 GET 方法檢索資源列表                          | 我收到了清單                         | 代碼 200 OK                              |
| 我想修改（使用 PUT 或 PATCH）或刪除（使用 DELETE）資源 | 根據所使用的方法，資源已被修改或刪除 | 代碼 200 OK 或 204 無內容                |
| 任何情況                                               | 發生意外錯誤（在伺服器層級）         | 代碼 500 內部伺服器錯誤                  |

:::tip HTTP 回應碼
在 [MDN（Mozilla 開發者網路）](https://developer.mozilla.org/en-US/docs/Web/HTTP/Status)網站上查看 HTTP 回應代碼清單。
:::

## REST 原則

要使 API 被視為“完全 REST”，理想情況下應遵循以下大部分原則。 透過遵守下面定義的各種約束，您可以採用許多程式語言和用戶端都熟知的風格。

### 統一介面（接口）

API 的介面應該是**統一**的：任何人都可以使用大家都熟悉的**標準**化格式來呼叫它。例如，我們可以定義使用**HTTP**請求和**JSON** 格式來呼叫我們的 API。 此後，伺服器上發生的事情只與伺服器有關。 應用程式介面的實作與定義為輸入的格式**無關**。

此後，我們將利用 4 項主要原則來定義統一的接口，使客戶端知道應該從伺服器那裡期待什麼，以及如何進行查詢：

**資源識別**

客戶端能夠唯一地識別資源，例如透過**URI（Uniform Resource Identifier - 統一資源識別碼）**。

例如，如果我想在電子郵件訂閱系統中將電子郵件傳送到伺服器，我可以使用 HTTP 和 URI `http://domain.tld/emails/4`。 這樣可以唯一標識一個資源。

**透過表示形式操作資源**

我們在前面討論過**格式**。 如果客戶端想要建立資源，它可以透過使用 `POST` 方法並使用特定格式（例如 JSON）的資源描述來表示資源。 然後，它可以將所需建立的資源的標準化表示附加在請求的正文中：

```json
POST /api/emails HTTP/1.1

{ "value": "test@test.com" }
```

**自述訊息**

伺服器將盡可能清晰地回應客戶端。

為此，它會根據情況使用適當的 HTTP 回應代碼（200、204、400 等）。

例如，在成功處理 `POST` 請求後，伺服器也可能發送存取相關資源的方法：

```json
HTTP/1.1 201 Created

{ "uri": "/api/emails/65" }
```

**HATEOAS（Hypermedia As The Engine Of Application State - 超媒體作為應用狀態的引擎）**

除了所提供的回應之外，伺服器還可以傳回其他訊息，使客戶端能夠繼續與應用程式介面進行互動。

這有點像是繼續使用應用程式介面時需要遵循的路徑，就像在遊戲中一樣：你執行了一個操作，然後系統會建議你繼續執行其他操作。

例如，如果我想要一份電子郵件列表，我會在 `/api/emails` 端點上使用 `GET` 請求。

然後，伺服器會傳回一個分頁的電子郵件清單（例如，每頁有 30 封）。 從邏輯上講，它會首先向我發送前 30 封郵件，與第一頁相對應。

然後，它可以添加有趣的信息，如其他頁面的連結：

> 伺服器回應

```json
HTTP/1.1 200 OK

{
  "emails": [
    { "uri": "/api/emails/1", "value": "test@test.net" },
    { "uri": "/api/emails/2", "value": "hello@gmail.com" },
    { "uri": "/api/emails/3", "value": "allgood@live.com" },
    // ...
  ],
  "_links": {
    "first": {
      "href": "http://localhost:8000/api/emails?page=1"
    },
    "prev": {
      "href": "http://localhost:8000/api/emails?page=1"
    },
    "self": {
      "href": "http://localhost:8000/api/emails?page=1"
    },
    "next": {
      "href": "http://localhost:8000/api/emails?page=2"
    },
    "last": {
      "href": "http://localhost:8000/api/emails?page=3"
    }
  },
}
```

### 客戶端-伺服器模型

在遵循客戶端/伺服器模型時，我們將完全分離客戶端部分和伺服器部分。 伺服器只處理**後端**任務，而一個或多個客戶端則負責**前端**任務。

因此，伺服器**不需要知道**哪些客戶端將來請求它。 伺服器部分和客戶端部分是完全獨立的，可以分別進行演進。

### 無狀態性

在伺服器端，不會保存有關與客戶端的當前會話的資訊。

相反，我們將規定獨立的請求應包含足夠的信息，以便伺服器能夠正確回應（例如，身份驗證/授權資訊）。

:::note 標頭和令牌
通常，我們將使用請求標頭來標識自己的身分以存取 API。 然後，我們將包括一個**令牌**（或訪問令牌）以進行身份驗證。 伺服器可以驗證令牌的有效性並授予與之相關的權限。

由於我們在每個請求中都使用相同的令牌，因此對於 Web 用戶端等，使用起來是透明的：我們只是處於已連線狀態。
:::

### 快取(緩存)（可選）

當伺服器回應客戶端時，它可以新增回應標頭以提供有關回應的保留指示（ [`Cache-Control`](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control) 標頭）。

因此，用戶端能夠在接收回應時將其緩存在本地，以備需要時**重複使用**。 標頭可以定義一定的保留期限，在此期限結束後，用戶端將被強制觸發新的請求以刷新資料。

:::info 最佳化(優化)
快取的使用是一個重要的最佳化措施：它可以顯著減少客戶端向伺服器發出的請求數量，使客戶端能夠重複使用已接收的資料。

但請務必嚴格控制數據的有效性。 如果客戶端不及時發出新請求，則有處理過時資料的風險。

:::

### 多層系統（可選）

從客戶端的角度來看，我們會請求一個包含 API 的伺服器。 實際上，該伺服器可能位於其他具有相同角色的伺服器中，其設定是為了在活動頻繁時分配負載（負載平衡）。

因此，客戶端可能認為它請求的是一台伺服器，但實際上它請求的是**負載平衡器**，例如，負載平衡器將決定請求的路由。

因此，客戶端可能會處理一個多層系統，但這是完全透明的：客戶端無需知道系統的建置方式。 這個約束與**客戶端/伺服器**部分相關：客戶端部分無需知道伺服器部分是如何開發、部署和組織的，而伺服器部分也無需知道哪些客戶端將請求它。

### 按需代碼（可選）

客戶端可以要求伺服器提供程式碼，然後執行該程式碼。
